<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>goghチョコ</title>
<style>
  :root{
    --choco-1:#4b2e2a;
    --choco-2:#6f443f;
    --choco-3:#8b5a51;
    --cream:#f6e9d7;
    --accent:#d39b7d;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP","Yu Gothic",sans-serif;background: linear-gradient(180deg,#2b1b18 0%, #1f1411 100%);color:var(--cream);}
  .app{
    max-width:1100px;margin:28px auto;padding:20px;border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
    box-shadow: 0 6px 30px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    display:flex;gap:20px;
  }

  /* Left: preview */
  .preview {
    width:640px;
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:center;
  }
  .canvas-wrap{
    width:550px;
    height:550px;
    background:linear-gradient(180deg,#2a1b17 0%, #1a0f0d 100%);
    border-radius:14px;
    padding:12px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.6), inset 0 3px 0 rgba(255,255,255,0.03);
    display:flex;align-items:center;justify-content:center;position:relative;
  }
  canvas#composite{
    width:526px;height:526px;background:#fff;border-radius:8px;display:block;
    image-rendering: crisp-edges;
    box-shadow: 0 6px 18px rgba(0,0,0,0.6);
  }
  /* Controls under preview */
  .controls{
    width:100%;
    display:flex;gap:8px;align-items:center;justify-content:space-between;
    flex-wrap:wrap;
  }
  .btn{
    background:linear-gradient(180deg,var(--choco-2),var(--choco-1));
    color:var(--cream);
    border:none;padding:10px 14px;border-radius:10px;cursor:pointer;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5);
    font-weight:600;
  }
  .btn.secondary{
    background: linear-gradient(180deg,var(--cream),#f0e7db);
    color:var(--choco-1);
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.12);
  }

  /* Right: layers list */
  .layers{
    flex:1;min-width:320px;max-width:420px;padding:8px;overflow:auto;
    max-height:700px;
  }
  .layers h2{margin:6px 0 12px 10px;color:var(--cream);}
  .layer{
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.08));
    margin:8px;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);
  }
  .layer.hidden-ui{
    display:none;
  }
  .layer-header{
    display:flex;align-items:center;justify-content:space-between;gap:8px;
  }
  .layer-title{font-weight:700;color:var(--cream)}
  .toggle-btn{
    background:transparent;border:1px solid rgba(255,255,255,0.03);padding:6px 10px;border-radius:8px;color:var(--cream);cursor:pointer;
    transition: all 0.2s ease;
  }
  .toggle-btn:hover{ background:rgba(255,255,255,0.05); }
  .toggle-btn.open{ transform: rotate(90deg); }
  .options{margin-top:10px;display:none;flex-wrap:wrap;gap:8px;}
  .options.open{display:flex;}
  .opt{ width:56px;height:56px;border-radius:8px;overflow:hidden;display:flex;align-items:center;justify-content:center; border:2px solid rgba(0,0,0,0.3);cursor:pointer;position:relative; transition: all 0.15s ease; }
  .opt:hover{ transform: scale(1.08); }
  .opt img{max-width:100%;max-height:100%;object-fit:cover;display:block;}
  .opt .label { position:absolute;bottom:2px;left:2px;right:2px;background:rgba(0,0,0,0.38);color:white;font-size:10px;padding:2px;border-radius:4px;text-align:center;max-height:20px;overflow:hidden;text-overflow:ellipsis;}
  .swatch{ width:48px;height:48px;border-radius:6px;border:1px solid rgba(0,0,0,0.2); }
  .opt.selected{outline:3px solid var(--accent);box-shadow: 0 4px 12px rgba(211,155,125,0.18);}

  /* Text/draw tool */
  .toolbox{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin:8px 0;}
  .size-indicator{width:32px;height:32px;border-radius:50%;background:#111;border:2px solid #222;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;font-size:12px;}

  /* small note */
  .note{position:fixed;right:14px;bottom:10px;font-size:12px;color:rgba(255,255,255,0.55);opacity:0.9}

  /* MODAL / DASHBOARD */
  .modal {
    position:fixed;left:0;top:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:2000;
  }
  .modal .card{
    width:360px;background:linear-gradient(180deg,#2d1f1c,#231410);padding:18px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);
  }
  .modal input[type="text"]{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.08);background:rgba(255,255,255,0.02);color:var(--cream)}

  .dashboard{
    position:fixed;left:0;top:0;right:0;bottom:0;background:linear-gradient(180deg,#150a09,#100706);z-index:1500;padding:24px;display:none;overflow:auto;
  }
  .dashboard .topbar{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px}
  .dashboard .container{display:flex;gap:12px}
  .dash-left{width:260px;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;overflow:auto;max-height:70vh}
  .dash-center{flex:1;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;text-align:center}
  .dash-right{width:320px;background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;overflow:auto;max-height:70vh}
  .user-row{padding:8px;border-radius:6px;margin-bottom:6px;background:rgba(0,0,0,0.12);cursor:pointer}
  .post-item{padding:8px;border-radius:6px;margin-bottom:6px;background:rgba(0,0,0,0.12)}

  .small-muted{font-size:12px;color:rgba(255,255,255,0.6)}

  /* Responsive */
  @media (max-width:1100px){
    .app{flex-direction:column;align-items:center;}
    .preview{width:100%}
    .layers{width:100%;max-height:none;}
    .dashboard .container{flex-direction:column}
    .dash-left,.dash-right{width:100%;max-height:none}
  }
</style>
</head>
<body>
<div class="app" role="application" aria-label="カスタムお菓子メーカー">
  <div class="preview" aria-hidden="false">
    <div style="display:flex;align-items:center;gap:12px;width:100%;justify-content:space-between;flex-wrap:wrap;">
      <h1 style="margin:0;color:var(--cream);font-size:18px">バレンタイン</h1>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
        <button class="btn" id="randomizeBtn" title="ランダム">ランダム</button>
        <button class="btn secondary" id="resetBtn" title="リセット">リセット</button>
        <button class="btn" id="saveBtn" title="画像を保存">保存</button>
        <button class="btn" id="sendBtn" title="送る">送る</button>
      </div>
    </div>

    <div class="canvas-wrap">
      <canvas id="composite" width="526" height="526" aria-label="プレビュー"></canvas>
      <canvas id="drawLayer" width="526" height="526" style="position:absolute;left:calc(50% - 263px);top:calc(50% - 263px);width:526px;height:526px;border-radius:8px;pointer-events:auto;"></canvas>
    </div>

    <div class="controls">
      <div class="toolbox">
        <button class="btn" id="writeModeBtn">ペン</button>
        <button class="btn" id="eraseModeBtn">消しゴム</button>
        <label style="display:flex;align-items:center;gap:6px;">
          <span style="font-size:13px;color:var(--cream)">太さ</span>
          <input id="sizeRange" type="range" min="1" max="40" value="9">
        </label>
        <div class="size-indicator" id="sizePreview"></div>
        <button class="btn secondary" id="clearDrawBtn">クリア</button>
      </div>
    </div>
  </div>

  <aside class="layers" aria-label="レイヤー一覧">
    <h2>レイヤー</h2>
    <div id="layersContainer"></div>
  </aside>
</div>

<!-- small note / credits -->
<div class="note">
  <p class="small-muted">※gogh二次創作ガイドラインの範囲内でご利用ください。非公式</p>
  <p class="small-muted"><a href="https://pocket-se.info/" style="color:var(--cream)">ポケットサウンド</a></p>
</div>

<!-- name input modal -->
<div id="nameModal" class="modal" style="display:none">
  <div class="card">
    <h3 style="margin:0 0 8px 0">送信するアカウント名を入力</h3>
    <p class="small-muted" style="margin:0 0 8px 0">※毎回同じ名前で入力してください（同じ名前なら同じアカウントに紐づきます）</p>
    <input id="inputName" type="text" placeholder="例: taro (記号は避けてください)">
    <div style="display:flex;gap:8px;margin-top:10px;justify-content:flex-end;">
      <button class="btn secondary" id="nameCancel">キャンセル</button>
      <button class="btn" id="nameConfirm">決定 / 登録</button>
    </div>
  </div>
</div>

<!-- dashboard (home2) -->
<div id="dashboard" class="dashboard" aria-hidden="true">
  <div class="topbar">
    <div style="display:flex;align-items:center;gap:12px;">
      <div style="font-weight:700">送れるチョコ</div>
      <div class="small-muted">あなたの表示</div>
    </div>
    <div style="display:flex;align-items:center;gap:10px;">
      <div id="dashName" class="small-muted">----</div>
      <label style="display:flex;align-items:center;gap:6px"><input id="anonToggle" type="checkbox"> 匿名表示</label>
      <button class="btn secondary" id="dashClose">ホームに戻る</button>
    </div>
  </div>

  <div class="container">
    <div class="dash-left">
      <h4 style="margin-top:0">送る一覧</h4>
      <div id="sendList"><div class="small-muted">読み込み中…</div></div>
    </div>

    <div class="dash-center">
      <div class="small-muted" style="margin-bottom:8px">送れるチョコ（プレビュー）</div>
      <canvas id="dashPreview" width="300" height="300" style="background:#fff;border-radius:8px;box-shadow:0 6px 14px rgba(0,0,0,0.6)"></canvas>
      <div style="margin-top:8px">
        <button class="btn" id="updateProfileBtn">自分の登録を更新（現在のデザインを保存）</button>
      </div>
    </div>

    <div class="dash-right">
      <h4 style="margin-top:0">ポスト一覧（あなた宛）</h4>
      <div id="postList"><div class="small-muted">読み込み中…</div></div>
    </div>
  </div>
</div>

<!-- audio elements -->
<audio id="hoverAudio" preload="auto" src="ppp.mp3"></audio>
<audio id="clickAudio" preload="auto" src="pp.mp3"></audio>

<script type="module">
  // Firebase (Realtime Database only) & app initialization
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-analytics.js";
  import { getDatabase, ref, set, push, onValue, get, child, update } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAuRmBnGdbatV47DyWiyzUUXApCedZdUYU",
    authDomain: "zzke-ki.firebaseapp.com",
    databaseURL: "https://zzke-ki-default-rtdb.firebaseio.com",
    projectId: "zzke-ki",
    storageBucket: "zzke-ki.firebasestorage.app",
    messagingSenderId: "155414272080",
    appId: "1:155414272080:web:de9733bf3b00da84e29955",
    measurementId: "G-XE4G5XVLSH"
  };

  const app = initializeApp(firebaseConfig);
  try { getAnalytics(app); } catch(e) { /* ignore in environments without GA */ }
  const db = getDatabase(app);

  /* ===========================
     The editor code (combined + unchanged functionality)
     - canvas size 526x526
     - layers defined below
     - drawing layer, eraser, save, etc.
     =========================== */

  // Layers definition (options include hidden:true to hide UI)
  const layers = [
    { id: 0, title: "背景", editable: true, options: [
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zzke-ki/main/1001.png", hidden: false },
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/1002.png", hidden: false }
      ]},
    { id: 1, title: "袋色", editable: true, options: [
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/201.png", hidden: false },
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/202.png", hidden: false }
      ]},
    { id: 2, title: "クリーム", editable: true, options: [
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/301.png", hidden: false }
      ]},
    { id: 3, title: "板チョコ", editable: true, options: [
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/401.png", hidden: false }
      ]},
    { id: 5, title: "キャラクター", editable: true, options: [
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/501.png", hidden: false }
      ]},
    { id: 6, title: "", editable: true, options: [
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/801.png", hidden: false }
      ]},
    { id: 7, title: "フレーム", editable: true, options: [
        { label:"なし", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/000.png", hidden: false },
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/601.png", hidden: false }
      ]},
    { id: 10, title: "キャラ枠", editable: true, options: [
        { label:"なし", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/000.png", hidden: false },
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/701.png", hidden: false }
      ]},
    { id: 8, title: "", editable: true, options: [
        { label:"", url:"https://raw.githubusercontent.com/zzcafe-280/zztyoko/main/901.png", hidden: true } // hidden UI but image can still be used/selected programmatically
      ]},
    { id: 9, title: "", editable: false, options: [] }
  ];

  // ---- State & DOM references ----
  const state = { selected: {}, imagesCache: {}, expandOpen: null, canvasSize: 526 };
  const layersContainer = document.getElementById('layersContainer');
  const composite = document.getElementById('composite');
  const drawLayer = document.getElementById('drawLayer');
  const ctx = composite.getContext('2d',{alpha:true});
  const drawCtx = drawLayer.getContext('2d',{alpha:true});
  const hoverAudio = document.getElementById('hoverAudio');
  const clickAudio = document.getElementById('clickAudio');

  const sizeRange = document.getElementById('sizeRange');
  const sizePreview = document.getElementById('sizePreview');
  const writeModeBtn = document.getElementById('writeModeBtn');
  const eraseModeBtn = document.getElementById('eraseModeBtn');
  const clearDrawBtn = document.getElementById('clearDrawBtn');
  const randomizeBtn = document.getElementById('randomizeBtn');
  const resetBtn = document.getElementById('resetBtn');
  const saveBtn = document.getElementById('saveBtn');
  const sendBtn = document.getElementById('sendBtn');

  // Dashboard elements
  const nameModal = document.getElementById('nameModal');
  const inputName = document.getElementById('inputName');
  const nameCancel = document.getElementById('nameCancel');
  const nameConfirm = document.getElementById('nameConfirm');

  const dashboard = document.getElementById('dashboard');
  const dashName = document.getElementById('dashName');
  const anonToggle = document.getElementById('anonToggle');
  const dashClose = document.getElementById('dashClose');
  const dashPreview = document.getElementById('dashPreview');
  const updateProfileBtn = document.getElementById('updateProfileBtn');
  const sendList = document.getElementById('sendList');
  const postList = document.getElementById('postList');

  let currentAccount = null; // registered name (sanitized key)
  let currentAccountDisplay = null; // display name (original input)

  // Helper: attach audio to buttons
  function attachButtonSound(el){
    el.addEventListener('mouseenter', ()=>{ try{ hoverAudio.currentTime=0; hoverAudio.play(); }catch(e){} });
    el.addEventListener('click', ()=>{ try{ clickAudio.currentTime=0; clickAudio.play(); }catch(e){} });
  }
  document.querySelectorAll('button,input[type="range"]').forEach(attachButtonSound);

  // ---- image loading/cache ----
  function loadImage(url){
    return new Promise((resolve)=>{
      if(!url){ resolve(null); return; }
      if(state.imagesCache[url]) {
        if(state.imagesCache[url].complete) resolve(state.imagesCache[url]);
        else state.imagesCache[url].addEventListener('load', ()=>resolve(state.imagesCache[url]));
        return;
      }
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = ()=>{ state.imagesCache[url] = img; resolve(img); };
      img.onerror = ()=>{ console.warn('image load error',url); resolve(null); };
      img.src = url;
      state.imagesCache[url] = img;
    });
  }

  // ---- UI: layers ----
  function buildLayersUI(){
    layersContainer.innerHTML = '';
    layers.sort((a,b)=>a.id-b.id).forEach(layer=>{
      const wrap = document.createElement('div'); wrap.className='layer'; wrap.dataset.layerId = layer.id;
      const allHidden = layer.editable && layer.options && layer.options.every(o => o.hidden);
      if(allHidden) wrap.classList.add('hidden-ui');

      const header = document.createElement('div'); header.className='layer-header';
      const title = document.createElement('div'); title.className='layer-title'; title.textContent = layer.title;
      header.appendChild(title);

      if(layer.editable){
        const toggle = document.createElement('button'); toggle.className='toggle-btn'; toggle.innerHTML = '&#x3e;';
        toggle.title = '切り替えを表示/非表示';
        toggle.addEventListener('click', (e)=>{
          e.preventDefault();
          if(state.expandOpen === layer.id) state.expandOpen = null;
          else state.expandOpen = layer.id;
          renderLayers();
        });
        header.appendChild(toggle);
      } else {
        const lock = document.createElement('div'); lock.style.opacity=0.7; lock.style.fontSize='13px'; lock.textContent='編集不可';
        header.appendChild(lock);
      }

      wrap.appendChild(header);

      const opts = document.createElement('div'); opts.className='options'; if(state.expandOpen === layer.id) opts.classList.add('open');

      if(layer.editable){
        layer.options.forEach(async (opt, idx)=>{
          if(opt.hidden) return; // do not create UI for hidden options
          const el = document.createElement('div'); el.className='opt'; el.title = opt.label || ('option-'+idx);
          const isColor = /^#([0-9a-f]{3,8})$/i.test(opt.label);
          if(isColor){
            const sw = document.createElement('div'); sw.className='swatch'; sw.style.background = opt.label; el.appendChild(sw);
          } else if(opt.url){
            const img = document.createElement('img'); img.src = opt.url; img.alt = opt.label || ''; el.appendChild(img);
            const lbl = document.createElement('div'); lbl.className='label'; lbl.textContent = opt.label; el.appendChild(lbl);
          } else {
            const txt = document.createElement('div'); txt.style.padding='4px'; txt.style.fontSize='13px'; txt.textContent = opt.label || 'none'; el.appendChild(txt);
          }
          if(state.selected[layer.id] === idx) el.classList.add('selected');
          el.addEventListener('click', async ()=>{
            state.selected[layer.id] = idx;
            renderLayers();
            await redrawComposite();
          });
          opts.appendChild(el);
          if(opt.url) loadImage(opt.url);
        });
      } else {
        const hint = document.createElement('div'); hint.style.fontSize='13px'; hint.style.opacity=0.8; hint.textContent = 'このレイヤーは描画専用です';
        opts.appendChild(hint);
      }

      wrap.appendChild(opts);
      layersContainer.appendChild(wrap);
    });
    document.querySelectorAll('.toggle-btn').forEach(btn => attachButtonSound(btn));
  }

  function renderLayers(){ buildLayersUI(); }

  function randomizeSelections(){
    layers.forEach(layer=>{
      if(!layer.editable) return;
      if(!layer.options || layer.options.length===0) return;
      const visibleOptions = layer.options.filter(o => !o.hidden);
      if(visibleOptions.length === 0) state.selected[layer.id] = 0;
      else {
        const randomIdx = Math.floor(Math.random() * visibleOptions.length);
        state.selected[layer.id] = layer.options.indexOf(visibleOptions[randomIdx]);
      }
    });
  }
  function resetSelections(){ layers.forEach(layer=>{ if(!layer.editable) return; state.selected[layer.id] = 0; }); }

  // ---- composite drawing ----
  function drawImageCover(ctxL, img, x, y, w, h){
    const iw = img.width, ih = img.height;
    if(!iw||!ih) return;
    const r = Math.max(w/iw, h/ih);
    const nw = iw * r, nh = ih * r;
    const cx = (nw - w) / 2, cy = (nh - h) / 2;
    ctxL.drawImage(img, -cx + x, -cy + y, nw, nh);
  }

  async function redrawComposite(){
    const size = state.canvasSize;
    ctx.clearRect(0,0,size,size);
    ctx.save(); ctx.fillStyle = '#fff'; ctx.fillRect(0,0,size,size); ctx.restore();

    for(const layer of layers){
      if(layer.id === 9) continue;
      if(!layer.editable) continue;
      const sel = state.selected[layer.id];
      if(sel === undefined) continue;
      const opt = layer.options[sel];
      if(!opt || !opt.url) continue;
      const img = await loadImage(opt.url);
      if(!img) continue;
      drawImageCover(ctx, img, 0,0,size,size);
    }
    ctx.drawImage(drawLayer, 0,0, state.canvasSize, state.canvasSize);
    // also update dashboard preview if open for convenience
    updateDashPreview();
  }

  // Save composite to PNG (download)
  async function saveComposite(){
    const size = state.canvasSize;
    const tmp = document.createElement('canvas'); tmp.width = size; tmp.height = size;
    const tctx = tmp.getContext('2d'); tctx.clearRect(0,0,size,size); tctx.fillStyle='#fff'; tctx.fillRect(0,0,size,size);
    for(const layer of layers){
      if(layer.id === 9) continue;
      if(!layer.editable) continue;
      const sel = state.selected[layer.id];
      if(sel === undefined) continue;
      const opt = layer.options[sel];
      if(!opt || !opt.url) continue;
      const img = await loadImage(opt.url);
      if(!img) continue;
      drawImageCover(tctx, img, 0,0,size,size);
    }
    tctx.drawImage(drawLayer, 0,0, size, size);
    const a = document.createElement('a'); a.href = tmp.toDataURL('image/png'); a.download = `custom_snack_${Date.now()}.png`; a.click();
  }

  // composite -> dataURL
  async function compositeDataURL(){
    const size = state.canvasSize;
    const tmp = document.createElement('canvas'); tmp.width = size; tmp.height = size;
    const tctx = tmp.getContext('2d'); tctx.clearRect(0,0,size,size); tctx.fillStyle='#fff'; tctx.fillRect(0,0,size,size);
    for(const layer of layers){
      if(layer.id === 9) continue;
      if(!layer.editable) continue;
      const sel = state.selected[layer.id];
      if(sel === undefined) continue;
      const opt = layer.options[sel];
      if(!opt || !opt.url) continue;
      const img = await loadImage(opt.url);
      if(!img) continue;
      drawImageCover(tctx, img, 0,0,size,size);
    }
    tctx.drawImage(drawLayer, 0,0, size, size);
    return tmp.toDataURL('image/png');
  }

  // ---- drawing layer (pen/eraser) ----
  let drawing = false;
  let erasing = false;
  let brushSize = parseInt(sizeRange.value,10) || 9;
  sizePreview.style.width = sizePreview.style.height = Math.max(24,brushSize*0.8)+'px';
  sizePreview.textContent = '';
  drawCtx.lineCap = 'round'; drawCtx.lineJoin = 'round'; drawCtx.strokeStyle = '#000'; drawCtx.lineWidth = brushSize;

  function setBrushSize(s){ brushSize = s; drawCtx.lineWidth = brushSize; sizePreview.style.width = sizePreview.style.height = Math.max(24,brushSize*0.8)+'px'; }
  sizeRange.addEventListener('input', (e)=>{ setBrushSize(parseInt(e.target.value,10)); });

  writeModeBtn.addEventListener('click', ()=>{ erasing = false; writeModeBtn.style.opacity = 1; eraseModeBtn.style.opacity = 0.8; });
  eraseModeBtn.addEventListener('click', ()=>{ erasing = true; eraseModeBtn.style.opacity = 1; writeModeBtn.style.opacity = 0.8; });
  clearDrawBtn.addEventListener('click', ()=>{ drawCtx.clearRect(0,0,drawLayer.width,drawLayer.height); redrawComposite(); });

  function getPointerPos(evt){
    const rect = drawLayer.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
    const x = (clientX - rect.left) * (drawLayer.width / rect.width);
    const y = (clientY - rect.top) * (drawLayer.height / rect.height);
    return {x,y};
  }

  let last = null;
  function pointerDown(e){ e.preventDefault(); drawing = true; last = getPointerPos(e); drawCtx.save(); if(erasing){ drawCtx.globalCompositeOperation = 'destination-out'; drawCtx.strokeStyle = 'rgba(0,0,0,1)'; } else { drawCtx.globalCompositeOperation = 'source-over'; drawCtx.strokeStyle = '#000'; } drawCtx.lineWidth = brushSize; drawCtx.beginPath(); drawCtx.moveTo(last.x,last.y); }
  function pointerMove(e){ if(!drawing) return; const p = getPointerPos(e); drawCtx.lineTo(p.x,p.y); drawCtx.stroke(); last = p; }
  function pointerUp(e){ if(!drawing) return; drawing = false; drawCtx.closePath(); drawCtx.restore(); redrawComposite(); }

  drawLayer.addEventListener('mousedown', pointerDown);
  drawLayer.addEventListener('touchstart', pointerDown, {passive:false});
  window.addEventListener('mousemove', pointerMove);
  window.addEventListener('touchmove', pointerMove, {passive:false});
  window.addEventListener('mouseup', pointerUp);
  window.addEventListener('touchend', pointerUp);

  /* ===========================
     New features: Firebase RTDB-backed "送る" flow and dashboard
     - sendBtn opens name input modal
     - nameConfirm -> register user in /users/{sanitizedName}
       stores: { displayName, anon:false, image: compositeDataURL(), updatedAt }
     - After registering, navigate to dashboard (home2)
     - Dashboard shows:
        - right top: your name + anon toggle (updates /users/{name}.anon)
        - left: send list (all users). If a user has anon=true show "匿名さん"
        - center: a preview of your saved image and button to "update profile" (saves current editor composite to /users/{name}.image)
        - right: post list for current user from /posts/{yourName}
     - Sending: Clicking a user in send list will create a post in /posts/{target}/{pushId} with { from: currentAccountDisplay, fromKey: currentAccount, fromAnon, image: compositeDataURL(), ts }
     - Posts appear in recipient's postList in real-time
     - Uses only Realtime Database
  =========================== */

  // sanitize name for RTDB key (remove illegal characters)
  function sanitizeKey(name){
    if(!name) return null;
    return String(name).trim().replace(/[.#$\/\[\]]/g,'_');
  }

  // register or update user profile (save current composite)
  async function registerOrUpdateProfile(nameInput){
    const key = sanitizeKey(nameInput);
    if(!key) throw new Error('無効な名前');
    const imgData = await compositeDataURL();
    const profileRef = ref(db, `users/${key}`);
    const payload = { displayName: nameInput.trim(), anon: false, image: imgData, updatedAt: Date.now() };
    await set(profileRef, payload);
    return { key, payload };
  }

  // load profile if exists
  async function loadProfileByName(nameInput){
    const key = sanitizeKey(nameInput);
    if(!key) return null;
    const snapshot = await get(child(ref(db), `users/${key}`));
    if(snapshot.exists()) return { key, profile: snapshot.val() };
    return null;
  }

  // update anonymous flag
  async function setAnonFlagForCurrent(on){
    if(!currentAccount) return;
    const profileRef = ref(db, `users/${currentAccount}`);
    await update(profileRef, { anon: !!on, updatedAt: Date.now() });
  }

  // update profile image only (from dashboard action)
  async function updateProfileImageForCurrent(){
    if(!currentAccount) return;
    const img = await compositeDataURL();
    await update(ref(db, `users/${currentAccount}`), { image: img, updatedAt: Date.now() });
  }

  // send current composite to target user
  async function sendToUser(targetKey){
    if(!currentAccount) { alert('先にアカウントを登録してください'); return; }
    if(!targetKey) return;
    const dataUrl = await compositeDataURL();
    const postRef = ref(db, `posts/${targetKey}`);
    const payload = { fromDisplay: currentAccountDisplay || currentAccount, fromKey: currentAccount, fromAnon: !!(await get(child(ref(db), `users/${currentAccount}/anon`))).val(), image: dataUrl, ts: Date.now() };
    await push(postRef, payload);
    alert('送信しました。');
  }

  // real-time listeners to maintain send list and posts
  let usersUnsub = null;
  let postsUnsub = null;

  function watchUsers(){
    const uref = ref(db, 'users');
    onValue(uref, (snap)=>{
      const val = snap.val() || {};
      renderSendList(val);
    });
  }

  function watchPostsForCurrent(){
    if(!currentAccount) return;
    const pref = ref(db, `posts/${currentAccount}`);
    onValue(pref, (snap)=>{
      const val = snap.val() || {};
      renderPostList(val);
    });
  }

  // render send list from users object
  function renderSendList(usersObj){
    sendList.innerHTML = '';
    const keys = Object.keys(usersObj || {}).sort();
    if(keys.length === 0){ sendList.innerHTML = '<div class="small-muted">登録ユーザーがいません</div>'; return; }
    keys.forEach(k=>{
      const u = usersObj[k];
      const nameDisplay = (u && u.anon) ? '匿名さん' : (u && u.displayName) || k;
      const row = document.createElement('div'); row.className = 'user-row';
      row.textContent = nameDisplay;
      row.addEventListener('click', ()=>{ // send to this user
        if(!confirm(`${nameDisplay} に現在のチョコを送りますか？`)) return;
        sendToUser(k);
      });
      sendList.appendChild(row);
    });
  }

  // render post list for current user
  function renderPostList(postsObj){
    postList.innerHTML = '';
    const keys = Object.keys(postsObj || {}).sort((a,b)=> (postsObj[b].ts || 0) - (postsObj[a].ts || 0));
    if(keys.length === 0){ postList.innerHTML = '<div class="small-muted">まだ届いていません</div>'; return; }
    keys.forEach(k=>{
      const p = postsObj[k];
      const el = document.createElement('div'); el.className = 'post-item';
      const from = p.fromAnon ? '匿名さん' : (p.fromDisplay || p.fromKey || '不明');
      const header = document.createElement('div'); header.style.marginBottom='6px'; header.innerHTML = `<strong>${from}</strong> <span class="small-muted" style="margin-left:8px">${new Date(p.ts||0).toLocaleString()}</span>`;
      el.appendChild(header);
      if(p.image){
        const img = document.createElement('img'); img.src = p.image; img.style.maxWidth='100%'; img.style.borderRadius='6px'; img.style.display='block';
        el.appendChild(img);
      }
      // Save button for recipient to download the received image
      const btn = document.createElement('button'); btn.className='btn secondary'; btn.style.marginTop='6px'; btn.textContent='保存';
      btn.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=p.image; a.download=`received_${k}.png`; a.click(); });
      el.appendChild(btn);
      postList.appendChild(el);
    });
  }

  // Utility: update DASH preview canvas (300x300) with last composite
  async function updateDashPreview(){
    const canvas = dashPreview;
    const dctx = canvas.getContext('2d');
    const size = state.canvasSize;
    dctx.clearRect(0,0,canvas.width,canvas.height);
    // draw current composite into canvas scaled to fit 300x300 (contain)
    const tmp = document.createElement('canvas'); tmp.width = size; tmp.height = size; const tctx = tmp.getContext('2d');
    tctx.fillStyle = '#fff'; tctx.fillRect(0,0,size,size);
    for(const layer of layers){
      if(layer.id === 9) continue;
      if(!layer.editable) continue;
      const sel = state.selected[layer.id];
      if(sel === undefined) continue;
      const opt = layer.options[sel];
      if(!opt || !opt.url) continue;
      const img = await loadImage(opt.url);
      if(!img) continue;
      drawImageCover(tctx, img, 0,0,size,size);
    }
    tctx.drawImage(drawLayer, 0,0, size, size);
    // scale down
    dctx.drawImage(tmp, 0,0, canvas.width, canvas.height);
  }

  /* ===========================
     UI Flow handlers
  =========================== */

  // open name modal
  function openNameModal(){
    nameModal.style.display = 'flex';
    inputName.value = '';
    inputName.focus();
  }
  // close modal
  function closeNameModal(){ nameModal.style.display = 'none'; }

  // When sendBtn clicked -> open modal
  sendBtn.addEventListener('click', ()=>{ openNameModal(); });

  nameCancel.addEventListener('click', ()=>{ closeNameModal(); });

  // Confirm name: register and open dashboard
  nameConfirm.addEventListener('click', async ()=>{
    const val = inputName.value.trim();
    if(!val){ alert('名前を入力してください'); return; }
    try{
      // Check existing: if exists, load and show that user's profile in dashboard center
      const existing = await loadProfileByName(val);
      const registration = await registerOrUpdateProfile(val);
      currentAccount = registration.key;
      currentAccountDisplay = registration.payload.displayName;
      // open dashboard
      openDashboard();
      closeNameModal();
      // start watchers
      watchUsers();
      watchPostsForCurrent();
      // set anon checkbox to the saved value (should be false after register)
      anonToggle.checked = false;
      // update dash preview from saved profile
      updateDashPreview();
    }catch(err){
      console.error(err); alert('登録に失敗しました'); 
    }
  });

  // open dashboard view
  function openDashboard(){
    if(!currentAccount) return;
    dashName.textContent = currentAccountDisplay || currentAccount;
    dashboard.style.display = 'block';
    dashboard.setAttribute('aria-hidden','false');
    // ensure posts listener is attached
    watchUsers();
    watchPostsForCurrent();
    // enable anon toggle handler
    anonToggle.onchange = async () => {
      await setAnonFlagForCurrent(anonToggle.checked);
    };
    // update preview initially
    updateDashPreview();
  }

  dashClose.addEventListener('click', ()=>{
    dashboard.style.display = 'none';
    dashboard.setAttribute('aria-hidden','true');
    // detach listeners if needed (onValue returns unsubscribe in v12? we used onValue without storing ref; okay it's persistent but acceptable for demo)
    // clear post list
    postList.innerHTML = '<div class="small-muted">閉じました</div>';
  });

  // Update profile image from dashboard (save current editor design)
  updateProfileBtn.addEventListener('click', async ()=>{
    if(!currentAccount){ alert('アカウントがありません'); return; }
    try{
      await updateProfileImageForCurrent();
      alert('プロフィールを更新しました（現在のデザインを保存しました）');
    }catch(e){ console.error(e); alert('更新に失敗しました'); }
  });

  // When clicking a user in send list, sendToUser called in renderSendList

  // ---- initialization ----
  async function init(){
    // initial UI setup
    randomizeSelections();
    buildLayersUI();
    await redrawComposite();

    // button wiring
    randomizeBtn.addEventListener('click', async ()=>{
      randomizeSelections(); renderLayers(); await redrawComposite();
    });
    resetBtn.addEventListener('click', async ()=>{
      resetSelections(); renderLayers(); await redrawComposite();
    });
    saveBtn.addEventListener('click', saveComposite);

    // keyboard: 'e' toggle eraser
    window.addEventListener('keydown',(e)=>{ if(e.key==='e'){ erasing = !erasing; eraseModeBtn.style.opacity = erasing?1:0.8; writeModeBtn.style.opacity = erasing?0.8:1; } });

    // attach audio to dynamic buttons
    document.querySelectorAll('button').forEach(attachButtonSound);
  }

  init();

  // Expose a small helper on window for debugging if needed
  window._gogh = { db, registerOrUpdateProfile, compositeDataURL };

</script>
</body>
</html>
